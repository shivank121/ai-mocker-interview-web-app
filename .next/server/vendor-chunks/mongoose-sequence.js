/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose-sequence";
exports.ids = ["vendor-chunks/mongoose-sequence"];
exports.modules = {

/***/ "(rsc)/./node_modules/mongoose-sequence/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose-sequence/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/sequence */ \"(rsc)/./node_modules/mongoose-sequence/lib/sequence.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2Utc2VxdWVuY2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsb0hBQTBDIiwic291cmNlcyI6WyIvaG9tZS9zaGl2YW5rL1Byb2plY3RzL2Z1bGxTdGFjay9haS1tb2NrZXItaW50ZXJ2aWV3LXdlYi1hcHAvbm9kZV9tb2R1bGVzL21vbmdvb3NlLXNlcXVlbmNlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvc2VxdWVuY2UnKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-sequence/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mongoose-sequence/lib/sequence.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose-sequence/lib/sequence.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/dist/async.mjs\");\nconst mongoose = __webpack_require__(/*! mongoose */ \"mongoose\");\nconst SequenceArchive = __webpack_require__(/*! ./sequence_archive */ \"(rsc)/./node_modules/mongoose-sequence/lib/sequence_archive.js\");\n\nconst sequenceArchive = SequenceArchive.getSingleton();\nlet Sequence;\n\nconst resolve = (path, obj) =>\n  path.split('.').reduce((prev, curr) => (prev ? prev[curr] : null), obj);\n\nmodule.exports = function SequenceFactory(connection) {\n  if (arguments.length !== 1) {\n    throw new Error(\n      'Please, pass mongoose while requiring mongoose-sequence: https://github.com/ramiel/mongoose-sequence#requiring',\n    );\n  }\n\n  /**\n   * Sequence plugin constructor\n   * @class Sequence\n   * @param {string} schema  the schema object\n   * @param {object} options A set of options for this plugin\n   * @param {string} [options.inc_field='_id'] The field to increment\n   * @param {string} [options.id='same as inc_field'] The id of this sequence.\n   * Mandatory only if the sequence use reference fields\n   * @param {string|string[]} [options.reference_fields=['_id']] Any field to consider as reference\n   * for the counter\n   * @param {boolean} [options.disable_hooks] If true any hook will be disabled\n   * @param {string} [options.collection_name='counters'] A name for the counter collection\n   * @param {boolean} [options.exclusive=true] Set False to allow sharing same Sequence with\n   *                                           multiple Schemas.\n   * @param {boolean} [options.parallel_hooks] If true any hook will be registered as parallel\n   * @param {Number} [options.start_seq=1] The number to start the sequence on\n   * @param {Number} [options.inc_amount=1] The number to increment by\n   * @throws {Error} If id is missing for counter which referes other fields\n   * @throws {Error} If A counter collide with another because of same id\n   */\n  Sequence = function (schema, options) {\n    const defaults = {\n      id: null,\n      inc_field: '_id',\n      start_seq: 1,\n      inc_amount: 1,\n      reference_fields: null,\n      disable_hooks: false,\n      collection_name: 'counters',\n      parallel_hooks: true,\n      exclusive: true,\n    };\n\n    const optionsNew = {\n      ...defaults,\n      ...options,\n    };\n\n    if (_.isNull(optionsNew.reference_fields)) {\n      optionsNew.reference_fields = optionsNew.inc_field;\n      this._useReference = false;\n    } else {\n      this._useReference = true;\n    }\n\n    optionsNew.reference_fields = _.isArray(optionsNew.reference_fields)\n      ? optionsNew.reference_fields\n      : [optionsNew.reference_fields];\n    optionsNew.reference_fields = optionsNew.reference_fields.sort();\n\n    if (this._useReference === true && _.isNull(optionsNew.id)) {\n      throw new Error('Cannot use reference fields without specifying an id');\n    } else {\n      optionsNew.id = optionsNew.id || optionsNew.inc_field;\n    }\n\n    this._options = optionsNew;\n    this._schema = schema;\n    this._counterModel = null;\n  };\n\n  /**\n   * Create an instance for a sequence\n   *\n   * @method     getInstance\n   * @param      {Object}    schema   A mongoose Schema\n   * @param      {object}    options  Options as accepted by A sequence\n   *                                  constructor\n   * @return     {Sequence}  A sequence\n   *\n   * @static\n   */\n  Sequence.getInstance = function (schema, options) {\n    const sequence = new Sequence(schema, options);\n    const id = sequence.getId();\n    const existsSequence = sequenceArchive.existsSequence(id);\n    sequence.enable();\n\n    if (!existsSequence) {\n      sequenceArchive.addSequence(id, sequence);\n    } else if (sequence._options.exclusive) {\n      throw new Error(`Counter already defined for field \"${id}\"`);\n    }\n\n    return sequence;\n  };\n\n  /**\n   * Enable the sequence creating all the necessary models\n   *\n   * @method     enable\n   */\n  Sequence.prototype.enable = function () {\n    this._counterModel = this._createCounterModel();\n\n    this._createSchemaKeys();\n\n    this._setMethods();\n\n    if (this._options.disable_hooks === false) {\n      this._setHooks();\n    }\n  };\n\n  /**\n   * Return the id of the sequence\n   *\n   * @method     getId\n   * @return     {String}  The id of the sequence\n   */\n  Sequence.prototype.getId = function () {\n    return this._options.id;\n  };\n\n  /**\n   * Given a mongoose document, retrieve the values of the fields set as reference\n   * for the sequence.\n   *\n   * @method     _getCounterReferenceField\n   * @param      {object}  doc     A mongoose document\n   * @return     {Array}   An array of strings which represent the value of the\n   *                       reference\n   */\n  Sequence.prototype._getCounterReferenceField = function (doc) {\n    let reference = {};\n\n    if (this._useReference === false) {\n      reference = null;\n    } else {\n      Object.keys(this._options.reference_fields).forEach((key) => {\n        reference[this._options.reference_fields[key]] = resolve(\n          this._options.reference_fields[key],\n          doc,\n        );\n      });\n    }\n\n    return reference;\n  };\n\n  /**\n   * Enrich the schema with keys needed by this sequence\n   *\n   * @method     _createSchemaKeys\n   */\n  Sequence.prototype._createSchemaKeys = function () {\n    const schemaKey = this._schema.path(this._options.inc_field);\n    if (_.isUndefined(schemaKey)) {\n      const fieldDesc = {};\n      fieldDesc[this._options.inc_field] = 'Number';\n      this._schema.add(fieldDesc);\n    } else if (schemaKey.instance !== 'Number') {\n      throw new Error(\n        'Auto increment field already present and not of type \"Number\"',\n      );\n    }\n  };\n\n  /**\n   * Create a model for the counter handled by this sequence\n   *\n   * @method     _createCounterModel\n   * @return     {Mongoose~Model}  A mongoose model\n   */\n  Sequence.prototype._createCounterModel = function () {\n    const CounterSchema = mongoose.Schema(\n      {\n        id: { type: String, required: true },\n        reference_value: { type: mongoose.Schema.Types.Mixed, required: true },\n        seq: { type: Number, default: this._options.start_seq, required: true },\n      },\n      {\n        collection: this._options.collection_name,\n        validateBeforeSave: false,\n        versionKey: false,\n        _id: false,\n      },\n    );\n    const modelName = `Counter_${this._options.id}`;\n\n    if (connection.modelNames().indexOf(modelName) >= 0) {\n      return connection.model(modelName);\n    }\n\n    CounterSchema.index({ id: 1, reference_value: 1 }, { unique: true });\n\n    /* Unused. Enable when is useful */\n    // CounterSchema.static('getNext', function(id, referenceValue, callback) {\n    //     this.findOne({ id: id, reference_value: referenceValue }, callback);\n    // });\n\n    return connection.model(modelName, CounterSchema);\n  };\n\n  /**\n   * Return a pre-save hook for this sequence\n   *\n   * @method     _getPreSaveHook\n   * @return     {function} A mongoose hook\n   */\n  Sequence.prototype._getPreSaveHook = function () {\n    const sequence = this;\n    return function (next, done) {\n      const doc = this;\n      let cb = done;\n      if (!sequence._options.parallel_hooks) {\n        cb = next;\n      }\n      if (sequence._options.parallel_hooks) {\n        next();\n      }\n      if (!doc.isNew) {\n        cb();\n        return;\n      }\n      sequence._createCounter(doc, (createErr, createSeq) => {\n        if (createErr) {\n          cb(createErr);\n          return;\n        }\n        if (!_.isNull(createSeq)) {\n          doc.set(sequence._options.inc_field, createSeq);\n          cb();\n        } else {\n          sequence._setNextCounter(doc, (setError, setSeq) => {\n            if (setError) {\n              cb(setError);\n              return;\n            }\n            doc.set(sequence._options.inc_field, setSeq);\n            cb();\n          });\n        }\n      });\n    };\n  };\n\n  /**\n   * Set and handler for some hooks on the schema referenced by this sequence\n   *\n   * @method     _setHooks\n   */\n  Sequence.prototype._setHooks = function () {\n    if (this._options.parallel_hooks) {\n      this._schema.pre('save', true, this._getPreSaveHook());\n    } else {\n      this._schema.pre('save', this._getPreSaveHook());\n    }\n  };\n\n  /**\n   * Set some useful methods on the schema\n   *\n   * @method     _setMethods\n   */\n  Sequence.prototype._setMethods = function () {\n    // this._schema.static('getNext', function(id, referenceValue, callback) {\n    //     this._counterModel.getNext(id, referenceValue, function(err, counter) {\n    //         if (err) return callback(err);\n    //         return callback(null, ++counter.seq);\n    //     });\n    // }.bind(this));\n\n    this._schema.method('setNext', function (id, callback) {\n      const sequence = sequenceArchive.getSequence(id);\n\n      if (_.isNull(sequence)) {\n        callback(\n          new Error(`Trying to increment a wrong sequence using the id ${id}`),\n        );\n        return;\n      }\n      // sequence = sequence.sequence;\n\n      sequence._createCounter(this, (createError, createSeq) => {\n        if (createError) {\n          callback(createError);\n          return;\n        }\n        if (!_.isNull(createSeq)) {\n          this.set(sequence._options.inc_field, createSeq);\n          this.save()\n            .then((data) => {\n              callback(null, data);\n            })\n            .catch((err) => {\n              callback(err);\n            });\n        } else {\n          sequence._setNextCounter(this, (setError, setSeq) => {\n            if (setError) {\n              callback(setError);\n              return;\n            }\n            this.set(sequence._options.inc_field, setSeq);\n            this.save()\n              .then((data) => {\n                callback(null, data);\n              })\n              .catch((err) => {\n                callback(err);\n              });\n          });\n        }\n      });\n    });\n\n    this._schema.static('counterReset', (id, reference, callback) => {\n      const sequence = sequenceArchive.getSequence(id);\n      sequence._resetCounter(id, reference, callback);\n    });\n  };\n\n  Sequence.prototype._resetCounter = function (id, reference, callback) {\n    const condition = { id };\n    let cb = callback;\n    let seq = 0;\n    if (reference instanceof Function) {\n      cb = reference;\n    } else {\n      condition.reference_value = this._getCounterReferenceField(reference);\n    }\n    if (this._options.start_seq) {\n      seq = this._options.start_seq - 1;\n    }\n    this._counterModel\n      .updateMany(condition, { $set: { seq } })\n      .then((data) => {\n        cb(null, data);\n      })\n      .catch((err) => {\n        cb(err);\n      });\n  };\n\n  /**\n   * Utility function to increment a counter in a transaction\n   *\n   * @method     _setNextCounter\n   * @param      {object}    doc       A mongoose model which need to receive the\n   *                                   increment\n   * @param      {Function}  callback  Called with the sequence counter\n   */\n  Sequence.prototype._setNextCounter = function (doc, callback) {\n    const retryable = (cb) => {\n      const id = this.getId();\n      const referenceValue = this._getCounterReferenceField(doc);\n      const incAmount = this._options.inc_amount;\n      this._counterModel\n        .findOneAndUpdate(\n          { id, reference_value: referenceValue },\n          { $inc: { seq: incAmount } },\n          { new: true, upsert: false },\n        )\n        .then((counter) => {\n          cb(null, counter.seq);\n        })\n        .catch((err) => {\n          cb(err);\n        });\n    };\n\n    async.retry({ times: 0 }, retryable, callback);\n  };\n\n  /**\n   * Utility function to create a record in counter before incrementing\n   *\n   * @method     _createCounter\n   * @param      {object}    doc       A mongoose model which need to receive the\n   *                                   increment\n   * @param      {Function}  callback  Called with the sequence counter\n   */\n  Sequence.prototype._createCounter = function (doc, callback) {\n    const id = this.getId();\n    const referenceValue = this._getCounterReferenceField(doc);\n    const startSeq = this._options.start_seq;\n    const counterModel = this._counterModel;\n\n    counterModel\n      .findOneAndUpdate(\n        {\n          id,\n          reference_value: referenceValue,\n        },\n        {},\n        {\n          upsert: true,\n          new: true,\n          setDefaultsOnInsert: true,\n          includeResultMetadata: true,\n        },\n      )\n      .then((counter) => {\n        // lastErrorObject.updatedExisting is true if new entry was upserted\n        if (\n          _.has(counter, 'lastErrorObject') &&\n          !counter.lastErrorObject.updatedExisting\n        ) {\n          return callback(null, startSeq);\n        }\n        return callback(null, null);\n      })\n      .catch((err) => {\n        // mongodb issues parallel upsert with primary key\n        // #Ref: https://jira.mongodb.org/browse/SERVER-14322\n        // #Ref: https://docs.mongodb.com/manual/reference/method/db.collection.update/#use-unique-indexes\n        if (err && err.code !== 11000) {\n          return callback(err);\n        }\n        return callback(null, null);\n      });\n  };\n\n  return Sequence.getInstance;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2Utc2VxdWVuY2UvbGliL3NlcXVlbmNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsd0RBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsMEJBQVU7QUFDbkMsd0JBQXdCLG1CQUFPLENBQUMsMEZBQW9COztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxHQUFHO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9zaGl2YW5rL1Byb2plY3RzL2Z1bGxTdGFjay9haS1tb2NrZXItaW50ZXJ2aWV3LXdlYi1hcHAvbm9kZV9tb2R1bGVzL21vbmdvb3NlLXNlcXVlbmNlL2xpYi9zZXF1ZW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG5jb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG5jb25zdCBTZXF1ZW5jZUFyY2hpdmUgPSByZXF1aXJlKCcuL3NlcXVlbmNlX2FyY2hpdmUnKTtcblxuY29uc3Qgc2VxdWVuY2VBcmNoaXZlID0gU2VxdWVuY2VBcmNoaXZlLmdldFNpbmdsZXRvbigpO1xubGV0IFNlcXVlbmNlO1xuXG5jb25zdCByZXNvbHZlID0gKHBhdGgsIG9iaikgPT5cbiAgcGF0aC5zcGxpdCgnLicpLnJlZHVjZSgocHJldiwgY3VycikgPT4gKHByZXYgPyBwcmV2W2N1cnJdIDogbnVsbCksIG9iaik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU2VxdWVuY2VGYWN0b3J5KGNvbm5lY3Rpb24pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUGxlYXNlLCBwYXNzIG1vbmdvb3NlIHdoaWxlIHJlcXVpcmluZyBtb25nb29zZS1zZXF1ZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL3JhbWllbC9tb25nb29zZS1zZXF1ZW5jZSNyZXF1aXJpbmcnLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VxdWVuY2UgcGx1Z2luIGNvbnN0cnVjdG9yXG4gICAqIEBjbGFzcyBTZXF1ZW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hICB0aGUgc2NoZW1hIG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNldCBvZiBvcHRpb25zIGZvciB0aGlzIHBsdWdpblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5jX2ZpZWxkPSdfaWQnXSBUaGUgZmllbGQgdG8gaW5jcmVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0nc2FtZSBhcyBpbmNfZmllbGQnXSBUaGUgaWQgb2YgdGhpcyBzZXF1ZW5jZS5cbiAgICogTWFuZGF0b3J5IG9ubHkgaWYgdGhlIHNlcXVlbmNlIHVzZSByZWZlcmVuY2UgZmllbGRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbb3B0aW9ucy5yZWZlcmVuY2VfZmllbGRzPVsnX2lkJ11dIEFueSBmaWVsZCB0byBjb25zaWRlciBhcyByZWZlcmVuY2VcbiAgICogZm9yIHRoZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGlzYWJsZV9ob29rc10gSWYgdHJ1ZSBhbnkgaG9vayB3aWxsIGJlIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb2xsZWN0aW9uX25hbWU9J2NvdW50ZXJzJ10gQSBuYW1lIGZvciB0aGUgY291bnRlciBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZXhjbHVzaXZlPXRydWVdIFNldCBGYWxzZSB0byBhbGxvdyBzaGFyaW5nIHNhbWUgU2VxdWVuY2Ugd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSBTY2hlbWFzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhcmFsbGVsX2hvb2tzXSBJZiB0cnVlIGFueSBob29rIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBwYXJhbGxlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRfc2VxPTFdIFRoZSBudW1iZXIgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbmNfYW1vdW50PTFdIFRoZSBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpZCBpcyBtaXNzaW5nIGZvciBjb3VudGVyIHdoaWNoIHJlZmVyZXMgb3RoZXIgZmllbGRzXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBBIGNvdW50ZXIgY29sbGlkZSB3aXRoIGFub3RoZXIgYmVjYXVzZSBvZiBzYW1lIGlkXG4gICAqL1xuICBTZXF1ZW5jZSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIGlkOiBudWxsLFxuICAgICAgaW5jX2ZpZWxkOiAnX2lkJyxcbiAgICAgIHN0YXJ0X3NlcTogMSxcbiAgICAgIGluY19hbW91bnQ6IDEsXG4gICAgICByZWZlcmVuY2VfZmllbGRzOiBudWxsLFxuICAgICAgZGlzYWJsZV9ob29rczogZmFsc2UsXG4gICAgICBjb2xsZWN0aW9uX25hbWU6ICdjb3VudGVycycsXG4gICAgICBwYXJhbGxlbF9ob29rczogdHJ1ZSxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3Qgb3B0aW9uc05ldyA9IHtcbiAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKF8uaXNOdWxsKG9wdGlvbnNOZXcucmVmZXJlbmNlX2ZpZWxkcykpIHtcbiAgICAgIG9wdGlvbnNOZXcucmVmZXJlbmNlX2ZpZWxkcyA9IG9wdGlvbnNOZXcuaW5jX2ZpZWxkO1xuICAgICAgdGhpcy5fdXNlUmVmZXJlbmNlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuXG4gICAgb3B0aW9uc05ldy5yZWZlcmVuY2VfZmllbGRzID0gXy5pc0FycmF5KG9wdGlvbnNOZXcucmVmZXJlbmNlX2ZpZWxkcylcbiAgICAgID8gb3B0aW9uc05ldy5yZWZlcmVuY2VfZmllbGRzXG4gICAgICA6IFtvcHRpb25zTmV3LnJlZmVyZW5jZV9maWVsZHNdO1xuICAgIG9wdGlvbnNOZXcucmVmZXJlbmNlX2ZpZWxkcyA9IG9wdGlvbnNOZXcucmVmZXJlbmNlX2ZpZWxkcy5zb3J0KCk7XG5cbiAgICBpZiAodGhpcy5fdXNlUmVmZXJlbmNlID09PSB0cnVlICYmIF8uaXNOdWxsKG9wdGlvbnNOZXcuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgcmVmZXJlbmNlIGZpZWxkcyB3aXRob3V0IHNwZWNpZnlpbmcgYW4gaWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uc05ldy5pZCA9IG9wdGlvbnNOZXcuaWQgfHwgb3B0aW9uc05ldy5pbmNfZmllbGQ7XG4gICAgfVxuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNOZXc7XG4gICAgdGhpcy5fc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuX2NvdW50ZXJNb2RlbCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBmb3IgYSBzZXF1ZW5jZVxuICAgKlxuICAgKiBAbWV0aG9kICAgICBnZXRJbnN0YW5jZVxuICAgKiBAcGFyYW0gICAgICB7T2JqZWN0fSAgICBzY2hlbWEgICBBIG1vbmdvb3NlIFNjaGVtYVxuICAgKiBAcGFyYW0gICAgICB7b2JqZWN0fSAgICBvcHRpb25zICBPcHRpb25zIGFzIGFjY2VwdGVkIGJ5IEEgc2VxdWVuY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3JcbiAgICogQHJldHVybiAgICAge1NlcXVlbmNlfSAgQSBzZXF1ZW5jZVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqL1xuICBTZXF1ZW5jZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IG5ldyBTZXF1ZW5jZShzY2hlbWEsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGlkID0gc2VxdWVuY2UuZ2V0SWQoKTtcbiAgICBjb25zdCBleGlzdHNTZXF1ZW5jZSA9IHNlcXVlbmNlQXJjaGl2ZS5leGlzdHNTZXF1ZW5jZShpZCk7XG4gICAgc2VxdWVuY2UuZW5hYmxlKCk7XG5cbiAgICBpZiAoIWV4aXN0c1NlcXVlbmNlKSB7XG4gICAgICBzZXF1ZW5jZUFyY2hpdmUuYWRkU2VxdWVuY2UoaWQsIHNlcXVlbmNlKTtcbiAgICB9IGVsc2UgaWYgKHNlcXVlbmNlLl9vcHRpb25zLmV4Y2x1c2l2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VudGVyIGFscmVhZHkgZGVmaW5lZCBmb3IgZmllbGQgXCIke2lkfVwiYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhlIHNlcXVlbmNlIGNyZWF0aW5nIGFsbCB0aGUgbmVjZXNzYXJ5IG1vZGVsc1xuICAgKlxuICAgKiBAbWV0aG9kICAgICBlbmFibGVcbiAgICovXG4gIFNlcXVlbmNlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY291bnRlck1vZGVsID0gdGhpcy5fY3JlYXRlQ291bnRlck1vZGVsKCk7XG5cbiAgICB0aGlzLl9jcmVhdGVTY2hlbWFLZXlzKCk7XG5cbiAgICB0aGlzLl9zZXRNZXRob2RzKCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXNhYmxlX2hvb2tzID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fc2V0SG9va3MoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaWQgb2YgdGhlIHNlcXVlbmNlXG4gICAqXG4gICAqIEBtZXRob2QgICAgIGdldElkXG4gICAqIEByZXR1cm4gICAgIHtTdHJpbmd9ICBUaGUgaWQgb2YgdGhlIHNlcXVlbmNlXG4gICAqL1xuICBTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbW9uZ29vc2UgZG9jdW1lbnQsIHJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgdGhlIGZpZWxkcyBzZXQgYXMgcmVmZXJlbmNlXG4gICAqIGZvciB0aGUgc2VxdWVuY2UuXG4gICAqXG4gICAqIEBtZXRob2QgICAgIF9nZXRDb3VudGVyUmVmZXJlbmNlRmllbGRcbiAgICogQHBhcmFtICAgICAge29iamVjdH0gIGRvYyAgICAgQSBtb25nb29zZSBkb2N1bWVudFxuICAgKiBAcmV0dXJuICAgICB7QXJyYXl9ICAgQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCByZXByZXNlbnQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlXG4gICAqL1xuICBTZXF1ZW5jZS5wcm90b3R5cGUuX2dldENvdW50ZXJSZWZlcmVuY2VGaWVsZCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICBsZXQgcmVmZXJlbmNlID0ge307XG5cbiAgICBpZiAodGhpcy5fdXNlUmVmZXJlbmNlID09PSBmYWxzZSkge1xuICAgICAgcmVmZXJlbmNlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fb3B0aW9ucy5yZWZlcmVuY2VfZmllbGRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgcmVmZXJlbmNlW3RoaXMuX29wdGlvbnMucmVmZXJlbmNlX2ZpZWxkc1trZXldXSA9IHJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fb3B0aW9ucy5yZWZlcmVuY2VfZmllbGRzW2tleV0sXG4gICAgICAgICAgZG9jLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5yaWNoIHRoZSBzY2hlbWEgd2l0aCBrZXlzIG5lZWRlZCBieSB0aGlzIHNlcXVlbmNlXG4gICAqXG4gICAqIEBtZXRob2QgICAgIF9jcmVhdGVTY2hlbWFLZXlzXG4gICAqL1xuICBTZXF1ZW5jZS5wcm90b3R5cGUuX2NyZWF0ZVNjaGVtYUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2NoZW1hS2V5ID0gdGhpcy5fc2NoZW1hLnBhdGgodGhpcy5fb3B0aW9ucy5pbmNfZmllbGQpO1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHNjaGVtYUtleSkpIHtcbiAgICAgIGNvbnN0IGZpZWxkRGVzYyA9IHt9O1xuICAgICAgZmllbGREZXNjW3RoaXMuX29wdGlvbnMuaW5jX2ZpZWxkXSA9ICdOdW1iZXInO1xuICAgICAgdGhpcy5fc2NoZW1hLmFkZChmaWVsZERlc2MpO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hS2V5Lmluc3RhbmNlICE9PSAnTnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXV0byBpbmNyZW1lbnQgZmllbGQgYWxyZWFkeSBwcmVzZW50IGFuZCBub3Qgb2YgdHlwZSBcIk51bWJlclwiJyxcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtb2RlbCBmb3IgdGhlIGNvdW50ZXIgaGFuZGxlZCBieSB0aGlzIHNlcXVlbmNlXG4gICAqXG4gICAqIEBtZXRob2QgICAgIF9jcmVhdGVDb3VudGVyTW9kZWxcbiAgICogQHJldHVybiAgICAge01vbmdvb3Nlfk1vZGVsfSAgQSBtb25nb29zZSBtb2RlbFxuICAgKi9cbiAgU2VxdWVuY2UucHJvdG90eXBlLl9jcmVhdGVDb3VudGVyTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgQ291bnRlclNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYShcbiAgICAgIHtcbiAgICAgICAgaWQ6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICByZWZlcmVuY2VfdmFsdWU6IHsgdHlwZTogbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk1peGVkLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICBzZXE6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiB0aGlzLl9vcHRpb25zLnN0YXJ0X3NlcSwgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNvbGxlY3Rpb246IHRoaXMuX29wdGlvbnMuY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICB2YWxpZGF0ZUJlZm9yZVNhdmU6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uS2V5OiBmYWxzZSxcbiAgICAgICAgX2lkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICBjb25zdCBtb2RlbE5hbWUgPSBgQ291bnRlcl8ke3RoaXMuX29wdGlvbnMuaWR9YDtcblxuICAgIGlmIChjb25uZWN0aW9uLm1vZGVsTmFtZXMoKS5pbmRleE9mKG1vZGVsTmFtZSkgPj0gMCkge1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ubW9kZWwobW9kZWxOYW1lKTtcbiAgICB9XG5cbiAgICBDb3VudGVyU2NoZW1hLmluZGV4KHsgaWQ6IDEsIHJlZmVyZW5jZV92YWx1ZTogMSB9LCB7IHVuaXF1ZTogdHJ1ZSB9KTtcblxuICAgIC8qIFVudXNlZC4gRW5hYmxlIHdoZW4gaXMgdXNlZnVsICovXG4gICAgLy8gQ291bnRlclNjaGVtYS5zdGF0aWMoJ2dldE5leHQnLCBmdW5jdGlvbihpZCwgcmVmZXJlbmNlVmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gICAgIHRoaXMuZmluZE9uZSh7IGlkOiBpZCwgcmVmZXJlbmNlX3ZhbHVlOiByZWZlcmVuY2VWYWx1ZSB9LCBjYWxsYmFjayk7XG4gICAgLy8gfSk7XG5cbiAgICByZXR1cm4gY29ubmVjdGlvbi5tb2RlbChtb2RlbE5hbWUsIENvdW50ZXJTY2hlbWEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwcmUtc2F2ZSBob29rIGZvciB0aGlzIHNlcXVlbmNlXG4gICAqXG4gICAqIEBtZXRob2QgICAgIF9nZXRQcmVTYXZlSG9va1xuICAgKiBAcmV0dXJuICAgICB7ZnVuY3Rpb259IEEgbW9uZ29vc2UgaG9va1xuICAgKi9cbiAgU2VxdWVuY2UucHJvdG90eXBlLl9nZXRQcmVTYXZlSG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0LCBkb25lKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzO1xuICAgICAgbGV0IGNiID0gZG9uZTtcbiAgICAgIGlmICghc2VxdWVuY2UuX29wdGlvbnMucGFyYWxsZWxfaG9va3MpIHtcbiAgICAgICAgY2IgPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHNlcXVlbmNlLl9vcHRpb25zLnBhcmFsbGVsX2hvb2tzKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghZG9jLmlzTmV3KSB7XG4gICAgICAgIGNiKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlcXVlbmNlLl9jcmVhdGVDb3VudGVyKGRvYywgKGNyZWF0ZUVyciwgY3JlYXRlU2VxKSA9PiB7XG4gICAgICAgIGlmIChjcmVhdGVFcnIpIHtcbiAgICAgICAgICBjYihjcmVhdGVFcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV8uaXNOdWxsKGNyZWF0ZVNlcSkpIHtcbiAgICAgICAgICBkb2Muc2V0KHNlcXVlbmNlLl9vcHRpb25zLmluY19maWVsZCwgY3JlYXRlU2VxKTtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcXVlbmNlLl9zZXROZXh0Q291bnRlcihkb2MsIChzZXRFcnJvciwgc2V0U2VxKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY2Ioc2V0RXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2Muc2V0KHNlcXVlbmNlLl9vcHRpb25zLmluY19maWVsZCwgc2V0U2VxKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBhbmQgaGFuZGxlciBmb3Igc29tZSBob29rcyBvbiB0aGUgc2NoZW1hIHJlZmVyZW5jZWQgYnkgdGhpcyBzZXF1ZW5jZVxuICAgKlxuICAgKiBAbWV0aG9kICAgICBfc2V0SG9va3NcbiAgICovXG4gIFNlcXVlbmNlLnByb3RvdHlwZS5fc2V0SG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMucGFyYWxsZWxfaG9va3MpIHtcbiAgICAgIHRoaXMuX3NjaGVtYS5wcmUoJ3NhdmUnLCB0cnVlLCB0aGlzLl9nZXRQcmVTYXZlSG9vaygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZW1hLnByZSgnc2F2ZScsIHRoaXMuX2dldFByZVNhdmVIb29rKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHNvbWUgdXNlZnVsIG1ldGhvZHMgb24gdGhlIHNjaGVtYVxuICAgKlxuICAgKiBAbWV0aG9kICAgICBfc2V0TWV0aG9kc1xuICAgKi9cbiAgU2VxdWVuY2UucHJvdG90eXBlLl9zZXRNZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMuX3NjaGVtYS5zdGF0aWMoJ2dldE5leHQnLCBmdW5jdGlvbihpZCwgcmVmZXJlbmNlVmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgLy8gICAgIHRoaXMuX2NvdW50ZXJNb2RlbC5nZXROZXh0KGlkLCByZWZlcmVuY2VWYWx1ZSwgZnVuY3Rpb24oZXJyLCBjb3VudGVyKSB7XG4gICAgLy8gICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAvLyAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCArK2NvdW50ZXIuc2VxKTtcbiAgICAvLyAgICAgfSk7XG4gICAgLy8gfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3NjaGVtYS5tZXRob2QoJ3NldE5leHQnLCBmdW5jdGlvbiAoaWQsIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBzZXF1ZW5jZSA9IHNlcXVlbmNlQXJjaGl2ZS5nZXRTZXF1ZW5jZShpZCk7XG5cbiAgICAgIGlmIChfLmlzTnVsbChzZXF1ZW5jZSkpIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKGBUcnlpbmcgdG8gaW5jcmVtZW50IGEgd3Jvbmcgc2VxdWVuY2UgdXNpbmcgdGhlIGlkICR7aWR9YCksXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHNlcXVlbmNlID0gc2VxdWVuY2Uuc2VxdWVuY2U7XG5cbiAgICAgIHNlcXVlbmNlLl9jcmVhdGVDb3VudGVyKHRoaXMsIChjcmVhdGVFcnJvciwgY3JlYXRlU2VxKSA9PiB7XG4gICAgICAgIGlmIChjcmVhdGVFcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfLmlzTnVsbChjcmVhdGVTZXEpKSB7XG4gICAgICAgICAgdGhpcy5zZXQoc2VxdWVuY2UuX29wdGlvbnMuaW5jX2ZpZWxkLCBjcmVhdGVTZXEpO1xuICAgICAgICAgIHRoaXMuc2F2ZSgpXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VxdWVuY2UuX3NldE5leHRDb3VudGVyKHRoaXMsIChzZXRFcnJvciwgc2V0U2VxKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soc2V0RXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldChzZXF1ZW5jZS5fb3B0aW9ucy5pbmNfZmllbGQsIHNldFNlcSk7XG4gICAgICAgICAgICB0aGlzLnNhdmUoKVxuICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NjaGVtYS5zdGF0aWMoJ2NvdW50ZXJSZXNldCcsIChpZCwgcmVmZXJlbmNlLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3Qgc2VxdWVuY2UgPSBzZXF1ZW5jZUFyY2hpdmUuZ2V0U2VxdWVuY2UoaWQpO1xuICAgICAgc2VxdWVuY2UuX3Jlc2V0Q291bnRlcihpZCwgcmVmZXJlbmNlLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2VxdWVuY2UucHJvdG90eXBlLl9yZXNldENvdW50ZXIgPSBmdW5jdGlvbiAoaWQsIHJlZmVyZW5jZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjb25kaXRpb24gPSB7IGlkIH07XG4gICAgbGV0IGNiID0gY2FsbGJhY2s7XG4gICAgbGV0IHNlcSA9IDA7XG4gICAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjYiA9IHJlZmVyZW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZGl0aW9uLnJlZmVyZW5jZV92YWx1ZSA9IHRoaXMuX2dldENvdW50ZXJSZWZlcmVuY2VGaWVsZChyZWZlcmVuY2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zdGFydF9zZXEpIHtcbiAgICAgIHNlcSA9IHRoaXMuX29wdGlvbnMuc3RhcnRfc2VxIC0gMTtcbiAgICB9XG4gICAgdGhpcy5fY291bnRlck1vZGVsXG4gICAgICAudXBkYXRlTWFueShjb25kaXRpb24sIHsgJHNldDogeyBzZXEgfSB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY2IobnVsbCwgZGF0YSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGluY3JlbWVudCBhIGNvdW50ZXIgaW4gYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAbWV0aG9kICAgICBfc2V0TmV4dENvdW50ZXJcbiAgICogQHBhcmFtICAgICAge29iamVjdH0gICAgZG9jICAgICAgIEEgbW9uZ29vc2UgbW9kZWwgd2hpY2ggbmVlZCB0byByZWNlaXZlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50XG4gICAqIEBwYXJhbSAgICAgIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsZWQgd2l0aCB0aGUgc2VxdWVuY2UgY291bnRlclxuICAgKi9cbiAgU2VxdWVuY2UucHJvdG90eXBlLl9zZXROZXh0Q291bnRlciA9IGZ1bmN0aW9uIChkb2MsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmV0cnlhYmxlID0gKGNiKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuZ2V0SWQoKTtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVZhbHVlID0gdGhpcy5fZ2V0Q291bnRlclJlZmVyZW5jZUZpZWxkKGRvYyk7XG4gICAgICBjb25zdCBpbmNBbW91bnQgPSB0aGlzLl9vcHRpb25zLmluY19hbW91bnQ7XG4gICAgICB0aGlzLl9jb3VudGVyTW9kZWxcbiAgICAgICAgLmZpbmRPbmVBbmRVcGRhdGUoXG4gICAgICAgICAgeyBpZCwgcmVmZXJlbmNlX3ZhbHVlOiByZWZlcmVuY2VWYWx1ZSB9LFxuICAgICAgICAgIHsgJGluYzogeyBzZXE6IGluY0Ftb3VudCB9IH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUsIHVwc2VydDogZmFsc2UgfSxcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoY291bnRlcikgPT4ge1xuICAgICAgICAgIGNiKG51bGwsIGNvdW50ZXIuc2VxKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucmV0cnkoeyB0aW1lczogMCB9LCByZXRyeWFibGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgYSByZWNvcmQgaW4gY291bnRlciBiZWZvcmUgaW5jcmVtZW50aW5nXG4gICAqXG4gICAqIEBtZXRob2QgICAgIF9jcmVhdGVDb3VudGVyXG4gICAqIEBwYXJhbSAgICAgIHtvYmplY3R9ICAgIGRvYyAgICAgICBBIG1vbmdvb3NlIG1vZGVsIHdoaWNoIG5lZWQgdG8gcmVjZWl2ZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudFxuICAgKiBAcGFyYW0gICAgICB7RnVuY3Rpb259ICBjYWxsYmFjayAgQ2FsbGVkIHdpdGggdGhlIHNlcXVlbmNlIGNvdW50ZXJcbiAgICovXG4gIFNlcXVlbmNlLnByb3RvdHlwZS5fY3JlYXRlQ291bnRlciA9IGZ1bmN0aW9uIChkb2MsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldElkKCk7XG4gICAgY29uc3QgcmVmZXJlbmNlVmFsdWUgPSB0aGlzLl9nZXRDb3VudGVyUmVmZXJlbmNlRmllbGQoZG9jKTtcbiAgICBjb25zdCBzdGFydFNlcSA9IHRoaXMuX29wdGlvbnMuc3RhcnRfc2VxO1xuICAgIGNvbnN0IGNvdW50ZXJNb2RlbCA9IHRoaXMuX2NvdW50ZXJNb2RlbDtcblxuICAgIGNvdW50ZXJNb2RlbFxuICAgICAgLmZpbmRPbmVBbmRVcGRhdGUoXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZWZlcmVuY2VfdmFsdWU6IHJlZmVyZW5jZVZhbHVlLFxuICAgICAgICB9LFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgIHVwc2VydDogdHJ1ZSxcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICBpbmNsdWRlUmVzdWx0TWV0YWRhdGE6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICApXG4gICAgICAudGhlbigoY291bnRlcikgPT4ge1xuICAgICAgICAvLyBsYXN0RXJyb3JPYmplY3QudXBkYXRlZEV4aXN0aW5nIGlzIHRydWUgaWYgbmV3IGVudHJ5IHdhcyB1cHNlcnRlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgXy5oYXMoY291bnRlciwgJ2xhc3RFcnJvck9iamVjdCcpICYmXG4gICAgICAgICAgIWNvdW50ZXIubGFzdEVycm9yT2JqZWN0LnVwZGF0ZWRFeGlzdGluZ1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc3RhcnRTZXEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvLyBtb25nb2RiIGlzc3VlcyBwYXJhbGxlbCB1cHNlcnQgd2l0aCBwcmltYXJ5IGtleVxuICAgICAgICAvLyAjUmVmOiBodHRwczovL2ppcmEubW9uZ29kYi5vcmcvYnJvd3NlL1NFUlZFUi0xNDMyMlxuICAgICAgICAvLyAjUmVmOiBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvI3VzZS11bmlxdWUtaW5kZXhlc1xuICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAxMTAwMCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTZXF1ZW5jZS5nZXRJbnN0YW5jZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-sequence/lib/sequence.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mongoose-sequence/lib/sequence_archive.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose-sequence/lib/sequence_archive.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\n * Create a new sequence archive\n */\nconst SequenceArchive = () => {\n  const sequences = new Map();\n\n  /**\n   * Check if a sequence already exists\n   *\n   * @param      {string}   id      The id of the sequence to look for\n   * @return     {boolean}\n   */\n  const existsSequence = (id) => sequences.has(id);\n\n  /**\n   * Add a new sequence to the archive\n   *\n   * @param      {array}          id        The id of the sequence\n   * @param      {Autoincrement}  sequence  A sequence\n   */\n  const addSequence = (id, sequence) => {\n    if (!existsSequence(id)) {\n      sequences.set(id, sequence);\n    }\n  };\n\n  /**\n   * Get a sequence by id\n   *\n   * @param      {string}  id      An id for the sequence\n   * @return     {object|null}  Return the found sequence or null\n   */\n  const getSequence = (id) => sequences.get(id) || null;\n\n  return {\n    existsSequence,\n    addSequence,\n    getSequence,\n  };\n};\n\nlet singleton = null;\n\n/**\n * Get a singleton SequenceArchive\n *\n * @return     {SequenceArchive}  A unique instance of SequenceArchive\n */\nSequenceArchive.getSingleton = function () {\n  if (!singleton) {\n    singleton = SequenceArchive();\n  }\n\n  return singleton;\n};\n\nmodule.exports = SequenceArchive;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2Utc2VxdWVuY2UvbGliL3NlcXVlbmNlX2FyY2hpdmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvaG9tZS9zaGl2YW5rL1Byb2plY3RzL2Z1bGxTdGFjay9haS1tb2NrZXItaW50ZXJ2aWV3LXdlYi1hcHAvbm9kZV9tb2R1bGVzL21vbmdvb3NlLXNlcXVlbmNlL2xpYi9zZXF1ZW5jZV9hcmNoaXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlIGEgbmV3IHNlcXVlbmNlIGFyY2hpdmVcbiAqL1xuY29uc3QgU2VxdWVuY2VBcmNoaXZlID0gKCkgPT4ge1xuICBjb25zdCBzZXF1ZW5jZXMgPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc2VxdWVuY2UgYWxyZWFkeSBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtICAgICAge3N0cmluZ30gICBpZCAgICAgIFRoZSBpZCBvZiB0aGUgc2VxdWVuY2UgdG8gbG9vayBmb3JcbiAgICogQHJldHVybiAgICAge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBleGlzdHNTZXF1ZW5jZSA9IChpZCkgPT4gc2VxdWVuY2VzLmhhcyhpZCk7XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzZXF1ZW5jZSB0byB0aGUgYXJjaGl2ZVxuICAgKlxuICAgKiBAcGFyYW0gICAgICB7YXJyYXl9ICAgICAgICAgIGlkICAgICAgICBUaGUgaWQgb2YgdGhlIHNlcXVlbmNlXG4gICAqIEBwYXJhbSAgICAgIHtBdXRvaW5jcmVtZW50fSAgc2VxdWVuY2UgIEEgc2VxdWVuY2VcbiAgICovXG4gIGNvbnN0IGFkZFNlcXVlbmNlID0gKGlkLCBzZXF1ZW5jZSkgPT4ge1xuICAgIGlmICghZXhpc3RzU2VxdWVuY2UoaWQpKSB7XG4gICAgICBzZXF1ZW5jZXMuc2V0KGlkLCBzZXF1ZW5jZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBzZXF1ZW5jZSBieSBpZFxuICAgKlxuICAgKiBAcGFyYW0gICAgICB7c3RyaW5nfSAgaWQgICAgICBBbiBpZCBmb3IgdGhlIHNlcXVlbmNlXG4gICAqIEByZXR1cm4gICAgIHtvYmplY3R8bnVsbH0gIFJldHVybiB0aGUgZm91bmQgc2VxdWVuY2Ugb3IgbnVsbFxuICAgKi9cbiAgY29uc3QgZ2V0U2VxdWVuY2UgPSAoaWQpID0+IHNlcXVlbmNlcy5nZXQoaWQpIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBleGlzdHNTZXF1ZW5jZSxcbiAgICBhZGRTZXF1ZW5jZSxcbiAgICBnZXRTZXF1ZW5jZSxcbiAgfTtcbn07XG5cbmxldCBzaW5nbGV0b24gPSBudWxsO1xuXG4vKipcbiAqIEdldCBhIHNpbmdsZXRvbiBTZXF1ZW5jZUFyY2hpdmVcbiAqXG4gKiBAcmV0dXJuICAgICB7U2VxdWVuY2VBcmNoaXZlfSAgQSB1bmlxdWUgaW5zdGFuY2Ugb2YgU2VxdWVuY2VBcmNoaXZlXG4gKi9cblNlcXVlbmNlQXJjaGl2ZS5nZXRTaW5nbGV0b24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghc2luZ2xldG9uKSB7XG4gICAgc2luZ2xldG9uID0gU2VxdWVuY2VBcmNoaXZlKCk7XG4gIH1cblxuICByZXR1cm4gc2luZ2xldG9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZW5jZUFyY2hpdmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mongoose-sequence/lib/sequence_archive.js\n");

/***/ })

};
;